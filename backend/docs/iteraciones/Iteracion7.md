# Iteraci√≥n 7 - Mejora del Sistema de Correcciones de Fichajes

## üìã Resumen

**Fecha:** 16 de Octubre de 2025  
**Objetivo:** Implementar campos dedicados para almacenar valores propuestos en correcciones de fichajes  
**Estado:** ‚úÖ COMPLETADA

---

## üéØ Motivaci√≥n

### Problema Identificado

En la implementaci√≥n anterior del sistema de correcciones, cuando un empleado solicitaba una correcci√≥n de fichaje con nuevos valores de `check_in` y `check_out`, estos valores propuestos se perd√≠an porque:

1. **Se almacenaban solo como texto** en el campo `correction_reason`
2. **No eran estructurados**, lo que imped√≠a:
   - Validaci√≥n de los valores propuestos
   - Comparaci√≥n con los valores originales
   - Aplicaci√≥n autom√°tica al aprobar
   - Consultas eficientes sobre correcciones pendientes

### Soluci√≥n Implementada

Se a√±adieron **dos nuevos campos** al modelo `Fichaje` para almacenar los valores propuestos de forma estructurada:

- `proposed_check_in: datetime | None`
- `proposed_check_out: datetime | None`

Esto permite:
- ‚úÖ Validar los valores propuestos antes de almacenarlos
- ‚úÖ Comparar autom√°ticamente con los valores originales
- ‚úÖ Aplicar los valores propuestos directamente al aprobar
- ‚úÖ Descartar los valores propuestos al rechazar
- ‚úÖ Realizar consultas sobre fichajes con correcciones pendientes

---

## üóÇÔ∏è Cambios Implementados

### 1. Modelo de Datos (`app/models/fichaje.py`)

**Campos a√±adidos:**

```python
# Valores propuestos en la correcci√≥n
proposed_check_in: datetime | None = Field(default=None)
proposed_check_out: datetime | None = Field(default=None)
```

**Ubicaci√≥n:** Despu√©s de `correction_requested_at`, antes de la informaci√≥n de aprobaci√≥n

**Caracter√≠sticas:**
- Tipo: `datetime | None` (opcional)
- Default: `None`
- No indexados (solo se usan temporalmente durante el proceso de correcci√≥n)

---

### 2. Esquemas Pydantic (`app/schemas/fichaje.py`)

**Cambios en `FichajeResponse`:**

```python
class FichajeResponse(BaseModel):
    # ... campos existentes ...
    
    # Informaci√≥n de correcci√≥n
    correction_reason: str | None = None
    correction_requested_at: str | None = None
    proposed_check_in: str | None = None  # ‚ú® NUEVO
    proposed_check_out: str | None = None  # ‚ú® NUEVO
    
    # ... resto de campos ...
```

**Actualizaci√≥n del serializador:**

```python
@field_serializer(
    "check_in",
    "check_out",
    "correction_requested_at",
    "proposed_check_in",      # ‚ú® NUEVO
    "proposed_check_out",     # ‚ú® NUEVO
    "approved_at",
    "created_at",
    "updated_at",
)
def serialize_datetime(self, dt: datetime | None, _info) -> str | None:
    """Serializa datetime a ISO 8601 con timezone UTC."""
    if dt is None:
        return None
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.isoformat().replace("+00:00", "Z")
```

---

### 3. Capa de Servicio (`app/services/fichaje_service.py`)

#### 3.1 Solicitud de Correcci√≥n

**M√©todo:** `request_correction()`

**Cambios:**

```python
async def request_correction(
    self,
    fichaje_id: int,
    user_id: int,
    reason: str,
    new_check_in: datetime,      # ‚ú® Nuevos valores propuestos
    new_check_out: datetime | None,
) -> Fichaje:
    # ... validaciones ...
    
    # Actualizar con valores propuestos
    fichaje.status = FichajeStatus.PENDING_CORRECTION
    fichaje.correction_reason = reason
    fichaje.correction_requested_at = datetime.now(tz=UTC)
    fichaje.proposed_check_in = new_check_in          # ‚ú® NUEVO
    fichaje.proposed_check_out = new_check_out        # ‚ú® NUEVO
    
    return await self.fichaje_repository.update(fichaje)
```

**Flujo:**
1. Empleado solicita correcci√≥n con nuevos valores
2. Sistema valida que los valores propuestos sean coherentes
3. **Almacena valores propuestos** en `proposed_check_in` y `proposed_check_out`
4. Valores originales (`check_in`, `check_out`) **permanecen intactos**
5. Estado cambia a `PENDING_CORRECTION`

#### 3.2 Aprobaci√≥n de Correcci√≥n

**M√©todo:** `approve_correction()`

**Cambios:**

```python
async def approve_correction(
    self,
    fichaje_id: int,
    hr_user_id: int,
    approved: bool,
    notes: str | None = None,
) -> Fichaje:
    # ... validaciones ...
    
    if approved:
        # Aplicar valores propuestos
        if fichaje.proposed_check_in:
            fichaje.check_in = fichaje.proposed_check_in      # ‚ú® Aplicar
        if fichaje.proposed_check_out:
            fichaje.check_out = fichaje.proposed_check_out    # ‚ú® Aplicar
        
        fichaje.status = FichajeStatus.CORRECTED
    else:
        fichaje.status = FichajeStatus.REJECTED
    
    # Limpiar valores propuestos en ambos casos
    fichaje.proposed_check_in = None      # ‚ú® Limpiar
    fichaje.proposed_check_out = None     # ‚ú® Limpiar
    
    # ... resto del c√≥digo ...
```

**Flujos:**

**A) Correcci√≥n APROBADA:**
1. HR revisa y aprueba
2. Sistema **copia** `proposed_check_in` ‚Üí `check_in`
3. Sistema **copia** `proposed_check_out` ‚Üí `check_out`
4. **Limpia** `proposed_check_in` y `proposed_check_out` (ya no son necesarios)
5. Estado cambia a `CORRECTED`
6. Registra aprobaci√≥n con HR, fecha y notas

**B) Correcci√≥n RECHAZADA:**
1. HR revisa y rechaza
2. **Descarta** valores propuestos (limpia campos)
3. **Preserva** valores originales en `check_in` y `check_out`
4. Estado cambia a `REJECTED`
5. Registra rechazo con HR, fecha y notas

---

### 4. Capa de API (`app/api/routers/fichajes.py`)

**Funci√≥n helper a√±adida:**

```python
def _build_fichaje_response(fichaje: Fichaje) -> dict:
    """
    Construye la respuesta de fichaje con todos los campos.
    
    Evita duplicaci√≥n de c√≥digo y asegura que todos los endpoints
    devuelven la misma estructura, incluyendo los campos propuestos.
    """
    return {
        "id": fichaje.id,
        "user_id": fichaje.user_id,
        "user": {
            "id": fichaje.user.id,
            "email": fichaje.user.email,
            "full_name": fichaje.user.full_name,
        },
        "check_in": fichaje.check_in,
        "check_out": fichaje.check_out,
        "status": fichaje.status,
        "notes": fichaje.notes,
        "correction_reason": fichaje.correction_reason,
        "correction_requested_at": fichaje.correction_requested_at,
        "proposed_check_in": fichaje.proposed_check_in,      # ‚ú® NUEVO
        "proposed_check_out": fichaje.proposed_check_out,    # ‚ú® NUEVO
        "approved_by": fichaje.approved_by,
        "approved_at": fichaje.approved_at,
        "approval_notes": fichaje.approval_notes,
        "hours_worked": fichaje.hours_worked,
        "is_complete": fichaje.is_complete,
        "is_pending_approval": fichaje.is_pending_approval,
        "created_at": fichaje.created_at,
        "updated_at": fichaje.updated_at,
    }
```

**Endpoints actualizados:**
- ‚úÖ `POST /api/fichajes/check-in` - Devuelve `proposed_check_in/out` (null)
- ‚úÖ `PUT /api/fichajes/{id}/check-out` - Devuelve `proposed_check_in/out` (null)
- ‚úÖ `GET /api/fichajes/` - Lista incluye `proposed_check_in/out`
- ‚úÖ `GET /api/fichajes/{id}` - Detalle incluye `proposed_check_in/out`
- ‚úÖ `POST /api/fichajes/{id}/correct` - Devuelve valores propuestos poblados
- ‚úÖ `POST /api/fichajes/{id}/approve` - Devuelve `proposed_check_in/out` (null tras aprobar/rechazar)

---

### 5. Migraci√≥n de Base de Datos

**Archivo:** `alembic/versions/20251016_2312-a21826898b46_add_proposed_check_in_check_out.py`

**Contenido:**

```python
"""add proposed_check_in_check_out

Revision ID: a21826898b46
Revises: b5b982037328
Create Date: 2025-10-16 23:12:43.123456

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel

# revision identifiers, used by Alembic.
revision = 'a21826898b46'
down_revision = 'b5b982037328'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """Add proposed_check_in and proposed_check_out columns to fichaje table."""
    with op.batch_alter_table('fichaje', schema=None) as batch_op:
        batch_op.add_column(
            sa.Column('proposed_check_in', sa.DateTime(), nullable=True)
        )
        batch_op.add_column(
            sa.Column('proposed_check_out', sa.DateTime(), nullable=True)
        )


def downgrade() -> None:
    """Remove proposed_check_in and proposed_check_out columns from fichaje table."""
    with op.batch_alter_table('fichaje', schema=None) as batch_op:
        batch_op.drop_column('proposed_check_out')
        batch_op.drop_column('proposed_check_in')
```

**Caracter√≠sticas:**
- Usa `batch_alter_table` para compatibilidad con SQLite
- Columnas opcionales (`nullable=True`)
- Tipo `DateTime` para almacenar fecha/hora
- Incluye `downgrade()` para rollback

**Comando ejecutado:**
```bash
make migrate  # Aplica la migraci√≥n
```

---

### 6. Datos de Prueba (`scripts/seed_data.py`)

**Fichajes de ejemplo a√±adidos:**

#### 6.1 Fichaje Pendiente de Correcci√≥n

```python
pending_fichaje = Fichaje(
    user_id=employee.id,
    check_in=wrong_check_in,           # 10:30 (incorrecto)
    check_out=wrong_check_out,         # 17:00 (incorrecto)
    status=FichajeStatus.PENDING_CORRECTION,
    correction_reason="Olvid√© fichar a tiempo, llegu√© a las 9:00 y sal√≠ a las 18:00",
    correction_requested_at=now - timedelta(hours=2),
    proposed_check_in=proposed_check_in,   # ‚ú® 09:00 (propuesto)
    proposed_check_out=proposed_check_out,  # ‚ú® 18:00 (propuesto)
)
```

**Estado:** Esperando aprobaci√≥n de HR  
**Valores actuales:** `10:30 - 17:00`  
**Valores propuestos:** `09:00 - 18:00`

#### 6.2 Fichaje Corregido y Aprobado

```python
corrected_fichaje = Fichaje(
    user_id=employee.id,
    check_in=corrected_check_in,       # 09:00 (ya corregido)
    check_out=corrected_check_out,     # 18:00 (ya corregido)
    status=FichajeStatus.CORRECTED,
    correction_reason="Error al fichar, entr√© a las 9:00 no a las 10:00",
    correction_requested_at=now - timedelta(days=4),
    approval_notes="Correcci√≥n aprobada. Horario verificado con el supervisor.",
    approved_at=now - timedelta(days=3),
    # proposed_check_in y proposed_check_out son None (ya aplicados y limpiados)
)
```

**Estado:** Correcci√≥n aprobada y aplicada  
**Valores finales:** `09:00 - 18:00` (ya corregidos)  
**Valores propuestos:** `None` (ya fueron aplicados y limpiados)

#### 6.3 Fichaje Rechazado

```python
rejected_fichaje = Fichaje(
    user_id=employee.id,
    check_in=rejected_check_in,        # 11:00 (original preservado)
    check_out=rejected_check_out,      # 16:00 (original preservado)
    status=FichajeStatus.REJECTED,
    correction_reason="Tuve una cita m√©dica",
    correction_requested_at=now - timedelta(days=2),
    approval_notes="Necesitas presentar justificante m√©dico",
    approved_at=now - timedelta(days=1),
    # proposed_check_in y proposed_check_out son None (descartados)
)
```

**Estado:** Correcci√≥n rechazada  
**Valores originales:** `11:00 - 16:00` (preservados)  
**Valores propuestos:** `None` (descartados al rechazar)

---

### 7. Tests (`tests/test_fichajes.py`)

**Clase de tests a√±adida:** `TestProposedCorrections`

#### Test 1: Valores Propuestos en Solicitud
```python
async def test_proposed_fields_in_correction_request(
    self, client: AsyncClient, auth_headers: dict, active_fichaje: Fichaje
):
    """Test que los valores propuestos se almacenan correctamente."""
    # Solicitar correcci√≥n con nuevos valores
    response = await client.post(
        f"/api/fichajes/{active_fichaje.id}/correct",
        json={
            "reason": "Forgot to clock in on time",
            "new_check_in": "2025-10-16T09:00:00Z",
            "new_check_out": "2025-10-16T18:00:00Z",
        },
        headers=auth_headers,
    )
    
    assert response.status_code == 200
    data = response.json()
    
    # Verificar que valores originales NO cambiaron
    assert original_check_in in data["check_in"]
    
    # Verificar que valores propuestos se almacenaron
    assert data["proposed_check_in"] is not None
    assert "09:00:00" in data["proposed_check_in"]
```

#### Test 2: Aplicaci√≥n en Aprobaci√≥n
```python
async def test_proposed_fields_applied_on_approval(
    self, client: AsyncClient, hr_headers: dict, pending_fichaje: Fichaje
):
    """Test que los valores propuestos se aplican al aprobar."""
    # Aprobar correcci√≥n
    response = await client.post(
        f"/api/fichajes/{pending_fichaje.id}/approve",
        json={"approved": True, "notes": "Approved"},
        headers=hr_headers,
    )
    
    assert response.status_code == 200
    data = response.json()
    
    # Verificar que valores propuestos se aplicaron
    assert "09:00:00" in data["check_in"]
    assert "18:00:00" in data["check_out"]
    
    # Verificar que campos propuestos se limpiaron
    assert data["proposed_check_in"] is None
    assert data["proposed_check_out"] is None
```

#### Test 3: Descarte en Rechazo
```python
async def test_proposed_fields_cleared_on_rejection(
    self, client: AsyncClient, hr_headers: dict, pending_fichaje: Fichaje
):
    """Test que los valores propuestos se descartan al rechazar."""
    # Rechazar correcci√≥n
    response = await client.post(
        f"/api/fichajes/{pending_fichaje.id}/approve",
        json={"approved": False, "notes": "Rejected"},
        headers=hr_headers,
    )
    
    assert response.status_code == 200
    data = response.json()
    
    # Verificar que valores originales se preservaron
    assert original_check_in in data["check_in"]
    
    # Verificar que campos propuestos se limpiaron
    assert data["proposed_check_in"] is None
    assert data["proposed_check_out"] is None
```

#### Test 4: Valores Nulos por Defecto
```python
async def test_proposed_fields_null_by_default(
    self, client: AsyncClient, auth_headers: dict
):
    """Test que los valores propuestos son null por defecto."""
    response = await client.post(
        "/api/fichajes/check-in",
        headers=auth_headers,
    )
    
    assert response.status_code == 201
    data = response.json()
    
    # Verificar que campos propuestos son null
    assert data["proposed_check_in"] is None
    assert data["proposed_check_out"] is None
```

#### Test 5: Inclusi√≥n en Listados
```python
async def test_list_fichajes_includes_proposed_fields(
    self, client: AsyncClient, hr_headers: dict
):
    """Test que el listado incluye los campos propuestos."""
    response = await client.get(
        "/api/fichajes/",
        headers=hr_headers,
    )
    
    assert response.status_code == 200
    data = response.json()
    
    # Verificar que todos los fichajes incluyen campos propuestos
    for fichaje in data["items"]:
        assert "proposed_check_in" in fichaje
        assert "proposed_check_out" in fichaje
```

**Resultado de tests:**
```bash
tests/test_fichajes.py::TestProposedCorrections::test_proposed_fields_in_correction_request PASSED
tests/test_fichajes.py::TestProposedCorrections::test_proposed_fields_applied_on_approval PASSED
tests/test_fichajes.py::TestProposedCorrections::test_proposed_fields_cleared_on_rejection PASSED
tests/test_fichajes.py::TestProposedCorrections::test_proposed_fields_null_by_default PASSED
tests/test_fichajes.py::TestProposedCorrections::test_list_fichajes_includes_proposed_fields PASSED

========== 13 correction tests passed ==========
```

---

## üîÑ Flujo Completo de Correcci√≥n

### Diagrama de Estados

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FICHAJE ORIGINAL (VALID)                      ‚îÇ
‚îÇ  check_in: 10:30    check_out: 17:00                            ‚îÇ
‚îÇ  proposed_check_in: null    proposed_check_out: null            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ Empleado solicita correcci√≥n
                              ‚îÇ (nuevos valores: 09:00 - 18:00)
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             CORRECCI√ìN SOLICITADA (PENDING_CORRECTION)          ‚îÇ
‚îÇ  check_in: 10:30    check_out: 17:00    ‚Üê Originales intactos  ‚îÇ
‚îÇ  proposed_check_in: 09:00                ‚Üê Nuevos valores       ‚îÇ
‚îÇ  proposed_check_out: 18:00               ‚Üê almacenados         ‚îÇ
‚îÇ  correction_reason: "Olvid√© fichar..."                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ                   ‚îÇ
           HR APRUEBA                HR RECHAZA
                    ‚îÇ                   ‚îÇ
                    ‚ñº                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  CORRECCI√ìN APROBADA        ‚îÇ  ‚îÇ  CORRECCI√ìN RECHAZADA        ‚îÇ
‚îÇ  (CORRECTED)                ‚îÇ  ‚îÇ  (REJECTED)                  ‚îÇ
‚îÇ                             ‚îÇ  ‚îÇ                              ‚îÇ
‚îÇ  check_in: 09:00  ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ  check_in: 10:30  ‚Üê Original ‚îÇ
‚îÇ  check_out: 18:00 ‚Üê Aplicado‚îÇ  ‚îÇ  check_out: 17:00 ‚Üê Preserva ‚îÇ
‚îÇ  proposed_check_in: null    ‚îÇ  ‚îÇ  proposed_check_in: null     ‚îÇ
‚îÇ  proposed_check_out: null   ‚îÇ  ‚îÇ  proposed_check_out: null    ‚îÇ
‚îÇ  approved_by: HR_ID         ‚îÇ  ‚îÇ  approved_by: HR_ID          ‚îÇ
‚îÇ  approval_notes: "OK"       ‚îÇ  ‚îÇ  approval_notes: "Rechazado" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Ejemplo de API Request/Response

#### 1. Solicitar Correcci√≥n

**Request:**
```http
POST /api/fichajes/123/correct
Authorization: Bearer <employee_token>
Content-Type: application/json

{
  "reason": "Olvid√© fichar a tiempo, llegu√© a las 9:00 y sal√≠ a las 18:00",
  "new_check_in": "2025-10-16T09:00:00Z",
  "new_check_out": "2025-10-16T18:00:00Z"
}
```

**Response:**
```json
{
  "id": 123,
  "user_id": 5,
  "check_in": "2025-10-16T10:30:00Z",
  "check_out": "2025-10-16T17:00:00Z",
  "status": "pending_correction",
  "correction_reason": "Olvid√© fichar a tiempo, llegu√© a las 9:00 y sal√≠ a las 18:00",
  "correction_requested_at": "2025-10-16T23:15:00Z",
  "proposed_check_in": "2025-10-16T09:00:00Z",
  "proposed_check_out": "2025-10-16T18:00:00Z",
  "approved_by": null,
  "approved_at": null,
  "approval_notes": null
}
```

#### 2. Aprobar Correcci√≥n (HR)

**Request:**
```http
POST /api/fichajes/123/approve
Authorization: Bearer <hr_token>
Content-Type: application/json

{
  "approved": true,
  "notes": "Correcci√≥n aprobada. Horario verificado con el supervisor."
}
```

**Response:**
```json
{
  "id": 123,
  "user_id": 5,
  "check_in": "2025-10-16T09:00:00Z",
  "check_out": "2025-10-16T18:00:00Z",
  "status": "corrected",
  "correction_reason": "Olvid√© fichar a tiempo, llegu√© a las 9:00 y sal√≠ a las 18:00",
  "correction_requested_at": "2025-10-16T23:15:00Z",
  "proposed_check_in": null,
  "proposed_check_out": null,
  "approved_by": 1,
  "approved_at": "2025-10-17T08:30:00Z",
  "approval_notes": "Correcci√≥n aprobada. Horario verificado con el supervisor."
}
```

---

## üìä Impacto en la Base de Datos

### Esquema Actualizado

```sql
CREATE TABLE fichaje (
    -- Campos existentes
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    check_in DATETIME NOT NULL,
    check_out DATETIME,
    status VARCHAR(50) NOT NULL,
    notes VARCHAR(500),
    
    -- Informaci√≥n de correcci√≥n
    correction_reason VARCHAR(1000),
    correction_requested_at DATETIME,
    
    -- ‚ú® NUEVOS CAMPOS
    proposed_check_in DATETIME,
    proposed_check_out DATETIME,
    
    -- Informaci√≥n de aprobaci√≥n
    approved_by INTEGER,
    approved_at DATETIME,
    approval_notes VARCHAR(500),
    
    -- Metadatos
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    
    -- Foreign Keys
    FOREIGN KEY (user_id) REFERENCES user(id),
    FOREIGN KEY (approved_by) REFERENCES user(id)
);
```

### Datos Existentes

- ‚úÖ **Migraci√≥n no destructiva**: Los datos existentes no se ven afectados
- ‚úÖ **Valores por defecto**: Los fichajes existentes tienen `proposed_check_in` y `proposed_check_out` en `NULL`
- ‚úÖ **Rollback disponible**: La migraci√≥n incluye `downgrade()` para revertir cambios

---

## ‚úÖ Validaciones Implementadas

### 1. Validaci√≥n de Valores Propuestos

```python
# En fichaje_service.py - request_correction()

# Validar que new_check_in sea anterior a new_check_out
if new_check_out and new_check_in >= new_check_out:
    raise ValueError(
        "proposed_check_in must be earlier than proposed_check_out"
    )

# Validar que los valores propuestos sean diferentes de los actuales
if (
    new_check_in == fichaje.check_in
    and new_check_out == fichaje.check_out
):
    raise ValueError(
        "Proposed values must be different from current values"
    )
```

### 2. Validaci√≥n de Estado

```python
# Solo se pueden solicitar correcciones en fichajes VALID
if fichaje.status != FichajeStatus.VALID:
    raise ValueError(
        f"Cannot request correction for fichaje with status {fichaje.status}"
    )

# Solo se pueden aprobar correcciones en estado PENDING_CORRECTION
if fichaje.status != FichajeStatus.PENDING_CORRECTION:
    raise ValueError(
        "Cannot approve correction for fichaje not in pending_correction status"
    )
```

### 3. Validaci√≥n de Permisos

```python
# Solo el propietario puede solicitar correcci√≥n
if fichaje.user_id != user_id:
    raise PermissionError("You can only request corrections for your own fichajes")

# Solo HR puede aprobar/rechazar correcciones
# (Validado en el router mediante Depends(get_hr_user))
```

---

## üöÄ Comandos Ejecutados

```bash
# 1. Crear migraci√≥n
make migration MESSAGE="add proposed_check_in_check_out"

# 2. Aplicar migraci√≥n
make migrate

# 3. Actualizar datos de prueba
make seed-clear

# 4. Ejecutar tests
pytest tests/test_fichajes.py::TestProposedCorrections -xvs

# 5. Ejecutar todos los tests de correcciones
pytest tests/test_fichajes.py -k "correction or Proposed" -v

# Resultado: 13 tests passed ‚úÖ
```

---

## üìà Beneficios de la Implementaci√≥n

### 1. **Datos Estructurados**
- ‚úÖ Los valores propuestos se almacenan como `datetime`, no como texto
- ‚úÖ Permite validaciones de tipo y formato
- ‚úÖ Facilita consultas y comparaciones

### 2. **Trazabilidad**
- ‚úÖ Se puede ver qu√© valores se propusieron originalmente
- ‚úÖ Se puede comparar con los valores actuales
- ‚úÖ Hist√≥rico completo del proceso de correcci√≥n

### 3. **Automatizaci√≥n**
- ‚úÖ Aplicaci√≥n autom√°tica de valores al aprobar
- ‚úÖ Limpieza autom√°tica de valores al aprobar/rechazar
- ‚úÖ No requiere parsing de texto para extraer valores

### 4. **Seguridad**
- ‚úÖ Valores originales protegidos hasta la aprobaci√≥n
- ‚úÖ Imposible modificar accidentalmente el fichaje original
- ‚úÖ Rollback impl√≠cito al rechazar (valores originales intactos)

### 5. **UX Mejorada**
- ‚úÖ Frontend puede mostrar valores propuestos vs actuales
- ‚úÖ Comparaci√≥n visual lado a lado
- ‚úÖ Validaci√≥n en tiempo real de valores propuestos

---

## üîç Casos de Uso Cubiertos

### ‚úÖ Caso 1: Empleado Olvid√≥ Fichar a Tiempo
**Escenario:** Empleado fich√≥ entrada a las 10:30 pero lleg√≥ a las 9:00

1. Empleado solicita correcci√≥n con `proposed_check_in: 09:00`
2. HR revisa y verifica con supervisor
3. HR aprueba, sistema aplica autom√°ticamente el valor
4. Fichaje actualizado a `check_in: 09:00`, estado `CORRECTED`

### ‚úÖ Caso 2: Error en Fichaje de Salida
**Escenario:** Empleado fich√≥ salida a las 15:00 pero sali√≥ a las 18:00

1. Empleado solicita correcci√≥n con `proposed_check_out: 18:00`
2. HR revisa y pide justificaci√≥n adicional
3. HR rechaza por falta de documentaci√≥n
4. Fichaje mantiene `check_out: 15:00`, estado `REJECTED`

### ‚úÖ Caso 3: Correcci√≥n de Ambos Valores
**Escenario:** Empleado se olvid√≥ de fichar completamente

1. Empleado solicita correcci√≥n con ambos valores propuestos
2. Sistema valida que `proposed_check_in < proposed_check_out`
3. HR aprueba tras verificar asistencia
4. Sistema aplica ambos valores autom√°ticamente

### ‚úÖ Caso 4: Consulta de Correcciones Pendientes
**Escenario:** HR quiere revisar todas las correcciones pendientes

```http
GET /api/fichajes/?status=pending_correction
```

**Response:** Lista de fichajes con valores propuestos visibles

---

## üìù Documentaci√≥n de API Actualizada

### Endpoint: Solicitar Correcci√≥n

```
POST /api/fichajes/{fichaje_id}/correct
```

**Request Body:**
```typescript
{
  reason: string;           // Motivo de la correcci√≥n
  new_check_in: string;     // ISO 8601 datetime
  new_check_out?: string;   // ISO 8601 datetime (opcional)
}
```

**Response:** `FichajeResponse` con:
- `status`: `"pending_correction"`
- `proposed_check_in`: Valor propuesto
- `proposed_check_out`: Valor propuesto (si aplica)
- `correction_reason`: Motivo proporcionado
- `correction_requested_at`: Timestamp de la solicitud

### Endpoint: Aprobar/Rechazar Correcci√≥n

```
POST /api/fichajes/{fichaje_id}/approve
```

**Request Body:**
```typescript
{
  approved: boolean;    // true = aprobar, false = rechazar
  notes?: string;       // Comentarios de HR (opcional)
}
```

**Response:** `FichajeResponse` con:
- Si `approved: true`:
  - `check_in`: Actualizado con `proposed_check_in`
  - `check_out`: Actualizado con `proposed_check_out`
  - `status`: `"corrected"`
  - `proposed_check_in`: `null` (limpiado)
  - `proposed_check_out`: `null` (limpiado)
  
- Si `approved: false`:
  - `check_in`: Sin cambios (original)
  - `check_out`: Sin cambios (original)
  - `status`: `"rejected"`
  - `proposed_check_in`: `null` (limpiado)
  - `proposed_check_out`: `null` (limpiado)

---

## üéì Lecciones Aprendidas

### 1. **Almacenar Datos Estructurados**
- ‚ùå **Mal:** Almacenar valores propuestos como texto en `correction_reason`
- ‚úÖ **Bien:** Usar campos dedicados con tipos apropiados (`datetime`)

### 2. **Separar Datos Temporales**
- ‚ùå **Mal:** Sobrescribir valores originales inmediatamente
- ‚úÖ **Bien:** Mantener valores propuestos separados hasta la aprobaci√≥n

### 3. **Limpieza de Datos**
- ‚ùå **Mal:** Dejar valores propuestos despu√©s de aprobar/rechazar
- ‚úÖ **Bien:** Limpiar campos propuestos una vez procesados

### 4. **Migraciones SQLite**
- ‚ùå **Mal:** Usar `alter_table` directamente (falla en SQLite)
- ‚úÖ **Bien:** Usar `batch_alter_table` para compatibilidad

### 5. **Test Coverage**
- ‚úÖ Cubrir flujo completo: solicitud ‚Üí aprobaci√≥n ‚Üí rechazo
- ‚úÖ Validar estado de los datos en cada paso
- ‚úÖ Verificar limpieza de campos temporales

---

## üîú Pr√≥ximos Pasos Sugeridos

### Mejoras Futuras

1. **Historial de Correcciones**
   - Crear tabla `fichaje_correction_history`
   - Almacenar todas las correcciones (aprobadas y rechazadas)
   - Permitir consultar historial completo

2. **Validaciones Adicionales**
   - L√≠mite de correcciones por fichaje (ej: m√°ximo 3 intentos)
   - Ventana temporal para solicitar correcciones (ej: solo √∫ltimos 7 d√≠as)
   - Validaci√≥n contra calendario laboral

3. **Notificaciones**
   - Notificar a HR cuando hay correcciones pendientes
   - Notificar a empleado cuando su correcci√≥n fue procesada
   - Dashboard de correcciones pendientes

4. **Auditor√≠a**
   - Registrar qui√©n aprob√≥/rechaz√≥ cada correcci√≥n
   - Timestamp de cada acci√≥n
   - Logs de cambios en campos cr√≠ticos

5. **M√©tricas**
   - Tasa de aprobaci√≥n de correcciones por empleado
   - Tiempo promedio de procesamiento
   - Motivos m√°s comunes de correcci√≥n

---

## ‚úÖ Conclusi√≥n

La implementaci√≥n de los campos `proposed_check_in` y `proposed_check_out` mejora significativamente el sistema de correcciones de fichajes:

- ‚úÖ **Datos estructurados** en lugar de texto libre
- ‚úÖ **Proceso claro** y automatizado
- ‚úÖ **Valores originales protegidos** hasta la aprobaci√≥n
- ‚úÖ **Test coverage completo** (13 tests de correcciones)
- ‚úÖ **Migraci√≥n aplicada** exitosamente
- ‚úÖ **Datos de prueba** actualizados
- ‚úÖ **API consistente** en todos los endpoints

El sistema ahora maneja correcciones de forma robusta, segura y escalable. üöÄ

---

**Documento generado:** 16 de Octubre de 2025  
**Versi√≥n:** 1.0  
**Estado:** ‚úÖ Implementaci√≥n Completa
